<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebRTC Test</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      max-width: 700px;
      margin: 20px auto;
      padding: 15px;
      line-height: 1.5;
    }
    h1 {
      text-align: center;
      color: #2c3e50;
      margin-bottom: 25px;
    }
    .controls {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    .room-actions {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    #roomIdInput {
      flex: 1;
      min-width: 200px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 16px;
    }
    button {
      padding: 10px 16px;
      font-size: 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: opacity 0.2s;
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .btn-create { background: #28a745; color: white; }
    .btn-create:hover:not(:disabled) { background: #218838; }
    .btn-join { background: #007bff; color: white; }
    .btn-join:hover:not(:disabled) { background: #0069d9; }
    .btn-send { background: #17a2b8; color: white; align-self: flex-end; }
    .btn-send:hover:not(:disabled) { background: #138496; }
    .btn-disconnect { background: #dc3545; color: white; margin-top: 10px; }
    .btn-disconnect:hover:not(:disabled) { background: #c82333; }
    
    #status {
      padding: 12px;
      border-radius: 6px;
      margin: 15px 0;
      text-align: center;
      font-weight: 500;
      min-height: 24px;
    }
    .status-idle { background: #e9ecef; color: #495057; }
    .status-connecting { background: #fff3cd; color: #856404; }
    .status-created { background: #d1ecf1; color: #0c5460; }
    .status-joining-peer { background: #fff3cd; color: #856404; }
    .status-connecting-ice { background: #d1ecf1; color: #0c5460; }
    .status-connected { background: #d4edda; color: #155724; }
    .status-error { background: #f8d7da; color: #721c24; }
    
    .room-id-display {
      background: #2c3e50;
      color: white;
      padding: 12px;
      border-radius: 6px;
      font-family: monospace;
      font-size: 18px;
      letter-spacing: 2px;
      text-align: center;
      margin: 15px 0;
      word-break: break-all;
    }
    .hidden { display: none; }
    
    .chat-container {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    #chatLog {
      min-height: 200px;
      max-height: 300px;
      overflow-y: auto;
      padding: 15px;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-family: monospace;
      line-height: 1.6;
    }
    .message {
      margin-bottom: 12px;
      padding-bottom: 12px;
      border-bottom: 1px dashed #eee;
    }
    .message:last-child {
      border-bottom: none;
      margin-bottom: 0;
      padding-bottom: 0;
    }
    .msg-you { color: #17a2b8; font-weight: 500; }
    .msg-peer { color: #e83e8c; font-weight: 500; }
    .msg-system { color: #6c757d; font-style: italic; }
    
    #messageInput {
      padding: 12px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 16px;
      resize: vertical;
      min-height: 60px;
    }
    
    /* Console monitor */
    #console-monitor {
      margin-top: 30px;
      border: 1px solid #ddd;
      border-radius: 6px;
      overflow: hidden;
      font-family: monospace;
      font-size: 13px;
    }
    #console-header {
      background: #2c3e50;
      color: white;
      padding: 8px 12px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
    }
    #console-content {
      background: #1e1e1e;
      color: #f8f8f2;
      height: 150px;
      overflow-y: auto;
      padding: 10px;
      white-space: pre-wrap;
    }
    .log { color: #f8f8f2; }
    .warn { color: #ffc107; }
    .error { color: #ff5252; }
    
    /* Diagnostic section */
    .diagnostic-section {
      margin: 10px 0;
      padding: 10px;
      background: #e7f3ff;
      border-radius: 4px;
      font-size: 14px;
    }
    #turnTestResult {
      margin-left: 10px;
      font-weight: 500;
    }
  </style>
</head>
<body>
  <h1>üîê WebRTC Test</h1>
  
  <div class="controls">
    <div class="room-actions">
      <button class="btn-create" id="createBtn">‚ú® Create Room</button>
      <input type="text" id="roomIdInput" placeholder="Enter room ID to join..." maxlength="12">
      <button class="btn-join" id="joinBtn">üö™ Join Room</button>
    </div>
    
    <div class="diagnostic-section">
      <strong>Protocol:</strong> <span id="protocolCheck">Checking...</span> |
      <button onclick="testTurnConnectivity()" style="padding: 6px 10px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;">
        üîç Test TURN
      </button>
      <span id="turnTestResult"></span>
    </div>
    
    <div id="status" class="status-idle">Not connected</div>
    
    <div id="createdRoomId" class="room-id-display hidden"></div>
    
    <div class="chat-container hidden" id="chatContainer">
      <div id="chatLog"></div>
      <textarea id="messageInput" placeholder="Type your message..." disabled></textarea>
      <button class="btn-send" id="sendBtn" disabled>Send</button>
    </div>
    
    <button class="btn-disconnect hidden" id="disconnectBtn">üîå Disconnect</button>
  </div>

  <div id="console-monitor">
    <div id="console-header" onclick="toggleConsole()">
      <strong>üìü Console</strong>
      <button id="clearConsole" onclick="clearConsole(event)" style="padding:2px 8px;font-size:12px;">Clear</button>
    </div>
    <div id="console-content"></div>
  </div>

  <script>
    // ===== CONSOLE MONITOR =====
    (function() {
      const consoleContent = document.getElementById('console-content');
      const originalLog = console.log;
      const originalWarn = console.warn;
      const originalError = console.error;
      
      function getTimestamp() {
        return new Date().toLocaleTimeString('en-US', { 
          hour12: false,
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        });
      }
      
      function addToConsole(prefix, className, ...args) {
        if (!consoleContent) return;
        
        const formattedArgs = args.map(arg => {
          if (arg instanceof Error) return arg.stack || arg.toString();
          if (typeof arg === 'object' && arg !== null) {
            try { return JSON.stringify(arg, null, 2); } catch { return arg.toString(); }
          }
          return String(arg);
        });
        
        const msgDiv = document.createElement('div');
        msgDiv.className = className;
        msgDiv.textContent = `${prefix} [${getTimestamp()}] ${formattedArgs.join(' ')}`;
        
        consoleContent.appendChild(msgDiv);
        consoleContent.scrollTop = consoleContent.scrollHeight;
        
        if (consoleContent.children.length > 200) {
          consoleContent.removeChild(consoleContent.firstChild);
        }
      }
      
      console.log = (...args) => { originalLog.apply(console, args); addToConsole('üîµ', 'log', ...args); };
      console.warn = (...args) => { originalWarn.apply(console, args); addToConsole('üü°', 'warn', ...args); };
      console.error = (...args) => { originalError.apply(console, args); addToConsole('üî¥', 'error', ...args); };
      
      window.clearConsole = (e) => { if (e) e.stopPropagation(); if (consoleContent) consoleContent.innerHTML = ''; };
      window.toggleConsole = () => { document.getElementById('console-content').classList.toggle('hidden'); };
      
      console.log('Console monitor initialized');
    })();
  </script>

  <script type="module">
    import WebRTCClient from './js/webRtc.js';
    
    // ===== HTTPS CHECK =====
    const protocolSpan = document.getElementById('protocolCheck');
    if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
      console.error('üî¥ WebRTC requires HTTPS! (except on localhost)');
      protocolSpan.textContent = 'HTTP ‚ùå (WebRTC requires HTTPS or localhost)';
      protocolSpan.style.color = '#dc3545';
      
      // Disable buttons with warning
      document.getElementById('createBtn').disabled = true;
      document.getElementById('joinBtn').disabled = true;
      document.getElementById('createBtn').title = 'WebRTC requires HTTPS or localhost';
      document.getElementById('joinBtn').title = 'WebRTC requires HTTPS or localhost';
    } else {
      protocolSpan.textContent = location.protocol === 'https:' ? 'HTTPS ‚úÖ' : 'localhost ‚úÖ';
      protocolSpan.style.color = '#28a745';
    }
    
    // ===== TURN SERVER CONFIGURATIONS =====
    // OPTION 1: Metered (public, may be rate-limited)
    const TURN_METERED = [
      { urls: 'stun:stun.l.google.com:19302' },
      {
        urls: [
          'turn:openrelay.metered.ca:80?transport=udp',
          'turn:openrelay.metered.ca:80?transport=tcp',
          'turn:openrelay.metered.ca:443?transport=tcp'
        ],
        username: 'openrelayproject',
        credential: 'openrelayproject'
      }
    ];
    
    // OPTION 2: STUN only (works on same network, fails behind NAT)
    const STUN_ONLY = [
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:stun1.l.google.com:19302' },
      { urls: 'stun:stun2.l.google.com:19302' },
      { urls: 'stun:stun3.l.google.com:19302' },
      { urls: 'stun:stun4.l.google.com:19302' }
    ];
    
    // OPTION 3: Twilio (requires signup - https://www.twilio.com/)
    // const TURN_TWILIO = [
    //   { urls: 'stun:global.stun.twilio.com:3478?transport=udp' },
    //   {
    //     urls: [
    //       'turn:global.turn.twilio.com:3478?transport=udp',
    //       'turn:global.turn.twilio.com:3478?transport=tcp',
    //       'turn:global.turn.twilio.com:443?transport=tcp'
    //     ],
    //     username: 'YOUR_TWILIO_USERNAME',
    //     credential: 'YOUR_TWILIO_CREDENTIAL'
    //   }
    // ];
    
    // SELECT TURN CONFIGURATION:
    let CURRENT_TURN_CONFIG = TURN_METERED; // Change to STUN_ONLY for same-network testing
    
    // DOM elements
    const createBtn = document.getElementById('createBtn');
    const joinBtn = document.getElementById('joinBtn');
    const roomIdInput = document.getElementById('roomIdInput');
    const statusDiv = document.getElementById('status');
    const createdRoomIdDiv = document.getElementById('createdRoomId');
    const chatContainer = document.getElementById('chatContainer');
    const chatLog = document.getElementById('chatLog');
    const messageInput = document.getElementById('messageInput');
    const sendBtn = document.getElementById('sendBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    
    let client = null;
    
    // UI state management
    function updateUI(state, details = {}) {
      statusDiv.className = '';
      createdRoomIdDiv.classList.add('hidden');
      chatContainer.classList.add('hidden');
      disconnectBtn.classList.add('hidden');
      messageInput.disabled = true;
      sendBtn.disabled = true;
      
      switch(state) {
        case 'idle':
          statusDiv.className = 'status-idle';
          statusDiv.textContent = 'Not connected';
          createBtn.disabled = false;
          joinBtn.disabled = false;
          break;
          
        case 'creating':
          statusDiv.className = 'status-connecting';
          statusDiv.textContent = 'Creating room...';
          createBtn.disabled = true;
          joinBtn.disabled = false;
          break;
          
        case 'joining':
          statusDiv.className = 'status-connecting';
          statusDiv.textContent = `Joining room ${roomIdInput.value}...`;
          createBtn.disabled = false;
          joinBtn.disabled = true;
          break;
          
        case 'created':
          statusDiv.className = 'status-created';
          statusDiv.textContent = `‚úì Room ${details.roomId} created! Waiting for peer...`;
          createdRoomIdDiv.textContent = details.roomId;
          createdRoomIdDiv.classList.remove('hidden');
          createBtn.disabled = true;
          joinBtn.disabled = false;
          break;
          
        case 'joined':
          statusDiv.className = 'status-joining-peer';
          statusDiv.textContent = `‚úì Joined room ${details.roomId}! Waiting for peer response...`;
          createBtn.disabled = false;
          joinBtn.disabled = true;
          break;
          
        case 'connecting-ice':
          statusDiv.className = 'status-connecting-ice';
          statusDiv.textContent = 'üîó Establishing secure connection... (may take 10-15s)';
          createBtn.disabled = true;
          joinBtn.disabled = true;
          break;
          
        case 'connected':
          statusDiv.className = 'status-connected';
          statusDiv.textContent = '‚úì Connected to peer!';
          chatContainer.classList.remove('hidden');
          disconnectBtn.classList.remove('hidden');
          messageInput.disabled = false;
          sendBtn.disabled = false;
          messageInput.focus();
          createBtn.disabled = true;
          joinBtn.disabled = true;
          break;
          
        case 'error':
          statusDiv.className = 'status-error';
          statusDiv.textContent = `‚ùå ${details.message || 'Connection failed'}`;
          createBtn.disabled = false;
          joinBtn.disabled = false;
          setTimeout(() => {
            if (statusDiv.className.includes('status-error')) {
              updateUI(client ? 'connected' : 'idle');
            }
          }, 8000);
          break;
      }
    }
    
    function getActionableErrorMessage(err) {
      const msg = err.message || String(err);
      if (msg.includes('TIMEOUT') || msg.includes('wait')) {
        return 'No peer found. Check room ID or ask host to refresh.';
      }
      if (msg.includes('failed') || msg.includes('ICE')) {
        return 'ICE negotiation failed. Try reloading or switching to STUN-only mode.';
      }
      if (msg.includes('EXPIRED')) {
        return 'Room expired. Host needs to create new room.';
      }
      if (msg.includes('Payload too large')) {
        return 'Message too large. Keep messages under 10MB.';
      }
      return `Connection failed: ${msg.substring(0, 60)}`;
    }
    
    function showError(message) {
      updateUI('error', { message });
    }
    
    function logMessage(type, text) {
      const div = document.createElement('div');
      div.className = 'message';
      
      switch(type) {
        case 'you':
          div.innerHTML = `<span class="msg-you">You:</span> ${escapeHtml(text)}`;
          break;
        case 'peer':
          div.innerHTML = `<span class="msg-peer">Peer:</span> ${escapeHtml(text)}`;
          break;
        default:
          div.innerHTML = `<span class="msg-system">[System]</span> ${escapeHtml(text)}`;
      }
      
      chatLog.appendChild(div);
      chatLog.scrollTop = chatLog.scrollHeight;
    }
    
    function escapeHtml(unsafe) {
      return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }
    
    // ===== CREATE ROOM WITH FALLBACK =====
    async function createRoomWithFallback() {
      if (client) return showError('Already connected! Disconnect first.');
      
      updateUI('creating');
      
      try {
        console.log('[TEST] Attempt 1: Creating room with TURN servers...');
        const result = await WebRTCClient.createRoom({ 
          debug: true, 
          iceServers: CURRENT_TURN_CONFIG,
          iceGatheringTimeout: 15000
        });
        client = result.client;
        setupListeners();
        updateUI('created', { roomId: result.roomId });
        logMessage('system', `Room created! Share ID: ${result.roomId}`);
        logMessage('system', CURRENT_TURN_CONFIG === STUN_ONLY ? 
          '‚ö†Ô∏è STUN-only mode (direct connection)' : 
          'Waiting for peer to join...');
        return true;
      } catch (err) {
        console.warn('[TEST] TURN attempt failed:', err.message);
        
        // Auto-fallback to STUN-only if TURN failed
        if (CURRENT_TURN_CONFIG !== STUN_ONLY) {
          if (confirm('TURN servers failed or unreachable.\n\n' +
                      'Try direct connection (STUN only)?\n\n' +
                      'This works if both peers are on the same network or have public IPs.')) {
            try {
              console.log('[TEST] Attempt 2: Creating room with STUN only...');
              CURRENT_TURN_CONFIG = STUN_ONLY;
              const result = await WebRTCClient.createRoom({ 
                debug: true, 
                iceServers: STUN_ONLY,
                iceGatheringTimeout: 10000
              });
              client = result.client;
              setupListeners();
              updateUI('created', { roomId: result.roomId });
              logMessage('system', `Room created (STUN only)! Share ID: ${result.roomId}`);
              logMessage('system', '‚ö†Ô∏è Direct connection mode - may fail behind firewalls/NAT');
              return true;
            } catch (err2) {
              console.error('[TEST] STUN-only attempt failed:', err2);
              showError('Both TURN and STUN failed. Check network/firewall settings.');
              updateUI('idle');
              return false;
            }
          } else {
            showError(getActionableErrorMessage(err));
            updateUI('idle');
            return false;
          }
        } else {
          showError(getActionableErrorMessage(err));
          updateUI('idle');
          return false;
        }
      }
    }
    
    async function joinRoom() {
      if (client) return showError('Already connected! Disconnect first.');
      
      const roomId = roomIdInput.value.trim();
      if (!roomId) return showError('Enter a room ID first');
      if (!/^[a-f0-9]{12}$/i.test(roomId)) {
        return showError('Invalid room ID format (must be 12 hex characters)');
      }
      
      updateUI('joining');
      
      try {
        console.log(`[TEST] Joining room ${roomId} with current config...`);
        client = await WebRTCClient.joinRoom(roomId, { 
          debug: true, 
          iceServers: CURRENT_TURN_CONFIG,
          iceGatheringTimeout: 15000
        });
        setupListeners();
        updateUI('joined', { roomId });
        logMessage('system', `Joined room ${roomId}!`);
      } catch (err) {
        console.error(`[TEST] Join room ${roomId} failed:`, err);
        showError(getActionableErrorMessage(err));
        updateUI('idle');
      }
    }
    
    function sendMessage() {
      const text = messageInput.value.trim();
      if (!text || !client) return;
      
      try {
        client.sendJSON({ type: 'chat', text, ts: Date.now() });
        logMessage('you', text);
        messageInput.value = '';
      } catch (err) {
        showError(`Send failed: ${err.message}`);
      }
    }
    
    function disconnect() {
      if (client) {
        client.close();
        cleanup();
        updateUI('idle');
        logMessage('system', 'Disconnected');
      }
    }
    
    function setupListeners() {
      // Track ICE/connection progress with detailed logging
      client.addEventListener('connectionstatechange', async (e) => {
        const state = e.detail.state;
        const iceState = e.detail.iceState;
        
        console.log(`[TEST] Connection state: ${state} | ICE state: ${iceState}`);
        
        // Diagnostic: Log ICE candidates when checking/connecting
        if (state === 'checking' || state === 'connected' || state === 'failed') {
          try {
            const candidates = await client.getIceCandidates();
            console.log(`[TEST] ICE Candidates - Local: ${candidates.local.length}, Remote: ${candidates.remote.length}`);
            
            if (candidates.local.length > 0) {
              console.log('[TEST] Local candidates:', candidates.local);
              
              // Check if we have relay candidates (TURN)
              const hasRelay = candidates.local.some(c => c.type === 'relay');
              if (!hasRelay && state === 'failed') {
                console.warn('üî¥ NO TURN CANDIDATES! Connection will fail behind NAT/firewall');
                console.warn('üí° Fix: Check TURN server credentials or try different TURN server');
              } else if (hasRelay) {
                console.log('‚úÖ TURN working - got relay candidate(s)');
              }
            }
            if (candidates.remote.length > 0) {
              console.log('[TEST] Remote candidates:', candidates.remote);
            }
          } catch (err) {
            console.error('[TEST] Error getting ICE candidates:', err);
          }
        }
        
        if (state === 'connecting' || state === 'checking') {
          updateUI('connecting-ice');
        } else if (state === 'failed') {
          showError('ICE negotiation failed! Common causes:\n' +
                    '1. TURN server unreachable or invalid credentials\n' +
                    '2. Firewall blocking UDP/TCP ports\n' +
                    '3. Running on HTTP (needs HTTPS except localhost)\n' +
                    '4. Network restrictions (corporate network)\n\n' +
                    'Try: Reload page, switch to STUN_ONLY if on same network, or use different TURN server');
        }
      });
      
      client.addEventListener('connect', () => {
        console.log('[TEST] ‚úì PEER CONNECTED!');
        updateUI('connected');
        logMessage('system', '‚úì PEER CONNECTED! Chat is live.');
      });
      
      client.addEventListener('disconnect', (e) => {
        const reason = e.detail?.reason || 'Peer disconnected';
        console.log('[TEST] Peer disconnected:', reason);
        logMessage('system', `‚ö† ${reason}`);
        if (client?.isConnected) {
          showError(`Connection lost: ${reason}`);
        }
      });
      
      client.addEventListener('close', cleanup);
      
      client.addEventListener('error', (e) => {
        console.error('[TEST] WebRTC error:', e.detail);
        showError(`WebRTC Error: ${e.detail}`);
      });
      
      client.addEventListener('json', (e) => {
        if (e.detail.type === 'chat') {
          logMessage('peer', e.detail.text);
        }
      });
    }
    
    function cleanup() {
      client = null;
      chatLog.innerHTML = '';
    }
    
    createBtn.addEventListener('click', createRoomWithFallback);
    joinBtn.addEventListener('click', joinRoom);
    sendBtn.addEventListener('click', sendMessage);
    disconnectBtn.addEventListener('click', disconnect);
    
    messageInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });
    
    updateUI('idle');
    console.log('[TEST] Page loaded. HTTPS check:', location.protocol === 'https:' || location.hostname === 'localhost' ? 'PASSED' : 'FAILED');
    console.log('[TEST] Current TURN config:', CURRENT_TURN_CONFIG === STUN_ONLY ? 'STUN_ONLY' : 'TURN_METERED');
    console.log('[TEST] ‚ÑπÔ∏è For production: Replace with your own TURN server credentials');
  </script>
  
  <script>
    // ===== TURN CONNECTIVITY TEST =====
    async function testTurnConnectivity() {
      const resultSpan = document.getElementById('turnTestResult');
      resultSpan.textContent = 'Testing...';
      resultSpan.style.color = '#856404';
      
      try {
        // Test 1: Can we reach STUN server?
        console.log('[TEST] Testing STUN server...');
        const pc1 = new RTCPeerConnection({
          iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        });
        
        let gotStunCandidate = false;
        pc1.onicecandidate = (e) => {
          if (e.candidate) {
            console.log('‚úÖ STUN candidate:', e.candidate.candidate.substring(0, 80) + '...');
            gotStunCandidate = true;
          }
        };
        
        pc1.createDataChannel('test');
        const offer1 = await pc1.createOffer();
        await pc1.setLocalDescription(offer1);
        
        // Wait for STUN candidates
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        if (!gotStunCandidate) {
          resultSpan.textContent = '‚ùå STUN failed (network issue)';
          resultSpan.style.color = '#dc3545';
          pc1.close();
          return;
        }
        
        // Test 2: Try TURN server
        console.log('[TEST] Testing TURN server...');
        const pc2 = new RTCPeerConnection({
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            {
              urls: [
                'turn:openrelay.metered.ca:80?transport=udp',
                'turn:openrelay.metered.ca:80?transport=tcp'
              ],
              username: 'openrelayproject',
              credential: 'openrelayproject'
            }
          ]
        });
        
        let gotRelay = false;
        let gotAnyCandidate = false;
        
        pc2.onicecandidate = (e) => {
          if (e.candidate) {
            gotAnyCandidate = true;
            console.log('Candidate:', e.candidate.candidate.substring(0, 80) + '...');
            if (e.candidate.candidate.includes('relay')) {
              gotRelay = true;
              console.log('‚úÖ TURN relay candidate received!');
            }
          }
        };
        
        pc2.createDataChannel('test2');
        const offer2 = await pc2.createOffer();
        await pc2.setLocalDescription(offer2);
        
        // Wait longer for TURN (can be slow)
        await new Promise(resolve => setTimeout(resolve, 6000));
        
        if (gotRelay) {
          resultSpan.textContent = '‚úÖ TURN OK!';
          resultSpan.style.color = '#28a745';
          console.log('‚úÖ TURN connectivity test PASSED');
        } else if (gotAnyCandidate) {
          resultSpan.textContent = '‚ö†Ô∏è STUN OK, TURN failed';
          resultSpan.style.color = '#ffc107';
          console.warn('‚ö†Ô∏è TURN server unreachable or credentials invalid. Direct connections may work.');
        } else {
          resultSpan.textContent = '‚ùå All ICE failed';
          resultSpan.style.color = '#dc3545';
          console.error('‚ùå No ICE candidates received. Check network/firewall.');
        }
        
        pc1.close();
        pc2.close();
        
      } catch (err) {
        resultSpan.textContent = '‚ùå Error: ' + err.message.substring(0, 30);
        resultSpan.style.color = '#dc3545';
        console.error('TURN test error:', err);
      }
    }
  </script>
</body>
</html>